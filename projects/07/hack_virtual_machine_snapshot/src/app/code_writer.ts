// Writes the assembly code that implements the parsed command

//   0 - 15   – Virtual Registers
//  16 - 255  – Static Variables
// 256 - 2047 – Stack

/*
SP:   RAM[0] Stack pointer
LCL:  RAM[1] Base address of the local segment
ARG:  RAM[2] Base address of argument segment
THIS: RAM[3] Base address of the this segment
THAT: RAM[4] Base address of the that segment
TEMP: RAM[5-12] Holds the temp segment
R13,
R14,  RAM[13-15] If the assembly code generated by the VM translator needs
R15              variables, it can use these register
*/

const REGISTER_SYMBOL = {
  stackPointer: "SP",
  local: "LCL",
  argument: "ARG",
  this: "THIS",
  that: "THAT",
  temp: "TEMP",
  R13: "R13",
  R14: "R14",
  R15: "R15",
} as const;

const REGISTER_ADDRESS = {
  temp: 5,
};

import * as multiline from "@utils/multiline.ts";

import * as parser from "./parser.ts";

let labelCount = 0;

export function writeCommand(
  VM_fileNameLessExtension: string,
  parsedCommand:
    | parser.ParsedArithmeticOrLogicalCommand
    | parser.ParsedPushOrPopCommand
    | string,
): string {
  if (typeof parsedCommand === "string") {
    // It's just a comment
    return parsedCommand;
  }

  const { command } = parsedCommand;

  if (command === "push" || command === "pop") {
    return handlePushOrPopCommand(VM_fileNameLessExtension, parsedCommand);
  }

  if (command === "add") {
    return multiline.stripIndent`
      // add
      @SP
      AM=M-1
      D=M
      A=A-1
      M=D+M
    `;
  }

  if (command === "sub") {
    return multiline.stripIndent`
      // sub
      @SP
      AM=M-1
      D=M
      A=A-1
      M=M-D
    `;
  }

  if (command === "neg") {
    return multiline.stripIndent`
      // neg
      @SP
      A=M-1
      M=-M
    `;
  }

  if (command === "eq") {
    const caseEqualLabel = `CASE_EQUAL_${labelCount}`;
    labelCount++;
    const endCaseLabel = `END_CASE_HANDLING_${labelCount}`;
    labelCount++;

    return multiline.stripIndent`
      // eq
      @SP
      AM=M-1
      D=M
      A=A-1
      D=M-D
      @${caseEqualLabel}
      D;JEQ
      @SP
      A=M-1
      M=0
      @${endCaseLabel}
      0;JMP
      (${caseEqualLabel})
      @SP
      A=M-1
      M=-1
      (${endCaseLabel})
    `;
  }

  if (command === "gt") {
    const caseGreaterThan = `CASE_GREATER_THAN_${labelCount}`;
    labelCount++;
    const endCaseLabel = `END_CASE_HANDLING_${labelCount}`;
    labelCount++;

    return multiline.stripIndent`
      // gt
      @SP
      AM=M-1
      D=M
      A=A-1
      D=M-D
      @${caseGreaterThan}
      D;JGT
      @SP
      A=M-1
      M=0
      @${endCaseLabel}
      0;JMP
      (${caseGreaterThan})
      @SP
      A=M-1
      M=-1
      (${endCaseLabel})
    `;
  }

  if (command === "lt") {
    const caseLessThan = `CASE_LESS_THAN_${labelCount}`;
    labelCount++;
    const endCaseLabel = `END_CASE_HANDLING_${labelCount}`;
    labelCount++;

    return multiline.stripIndent`
      // lt
      @SP
      AM=M-1
      D=M
      A=A-1
      D=M-D
      @${caseLessThan}
      D;JLT
      @SP
      A=M-1
      M=0
      @${endCaseLabel}
      0;JMP
      (${caseLessThan})
      @SP
      A=M-1
      M=-1
      (${endCaseLabel})
    `;
  }

  if (command === "and") {
    return multiline.stripIndent`
      // and
      @SP
      AM=M-1
      D=M
      A=A-1
      M=D&M
    `;
  }

  if (command === "or") {
    return multiline.stripIndent`
      // or
      @SP
      AM=M-1
      D=M
      A=A-1
      M=D|M
    `;
  }

  if (command === "not") {
    return multiline.stripIndent`
      // not
      @SP
      A=M-1
      M=!M
    `;
  }

  throw new Error(
    `Unhandled command: ${JSON.stringify(parsedCommand, null, 2)}`,
  );
}

function handlePushOrPopCommand(
  VM_fileNameLessExtension: string,
  parsedCommand: parser.ParsedPushOrPopCommand,
) {
  const { command, segment, value } = parsedCommand;

  if (value < 0) {
    throw new Error(
      `Only non-negative integers allowed. Got: ${
        (JSON.stringify(parsedCommand), null, 2)
      }`,
    );
  }

  const commandComment = `// ${command} ${segment} ${value}`;

  if (segment === "constant" && command === "push") {
    return multiline.stripIndent`
      ${commandComment}
      @${value}
      D=A
      @SP
      M=M+1
      A=M-1
      M=D
    `;
  }

  if (
    segment === "local" ||
    segment === "argument" ||
    segment === "this" ||
    segment === "that"
  ) {
    const segmentSymbol = REGISTER_SYMBOL[segment];

    if (command === "push") {
      return multiline.stripIndent`
        ${commandComment}
        @${segmentSymbol}
        D=M
        @${value}
        A=D+A
        D=M
        @${REGISTER_SYMBOL.stackPointer}
        M=M+1
        A=M-1
        M=D
      `;
    }

    if (command === "pop") {
      return multiline.stripIndent`
        ${commandComment}
        @${segmentSymbol}
        D=M
        @${value}
        D=D+A
        @R13
        M=D
        @SP
        AM=M-1
        D=M
        @R13
        A=M
        M=D
      `;
    }
  }

  if (segment === "pointer") {
    if (value !== 0 && value !== 1) {
      throw new Error(
        `Value must equal 0 or 1, to correspond to 'THIS' or 'THAT'. Was: ${value}`,
      );
    }

    const valueSymbol =
      value === 0 ? REGISTER_SYMBOL.this : REGISTER_SYMBOL.that;

    if (command === "push") {
      return multiline.stripIndent`
        ${commandComment}
        @${valueSymbol}
        D=M
        @${REGISTER_SYMBOL.stackPointer}
        M=M+1
        A=M-1
        M=D
      `;
    }

    if (command === "pop") {
      return multiline.stripIndent`
        ${commandComment}
        @SP
        AM=M-1
        D=M
        @${valueSymbol}
        M=D
      `;
    }
  }

  if (segment === "temp") {
    if (value > 7) {
      throw new Error(
        `Used a value greater than 7 in command: ${JSON.stringify(
          parsedCommand,
          null,
          2,
        )}`,
      );
    }

    if (command === "push") {
      return multiline.stripIndent`
        ${commandComment}
        @${REGISTER_ADDRESS.temp}
        D=A
        @${value}
        D=D+A
        A=D
        D=M
        @SP
        M=M+1
        A=M-1
        M=D
      `;
    }
    if (command === "pop") {
      return multiline.stripIndent`
        ${commandComment}
        @${REGISTER_ADDRESS.temp}
        D=A
        @${value}
        D=D+A
        @R13
        M=D
        @SP
        AM=M-1
        D=M
        @R13
        A=M
        M=D
      `;
    }
  }

  if (segment === "static") {
    if (value > 239) {
      throw new Error(
        `Used a value greater than 239 in command: ${JSON.stringify(
          parsedCommand,
          null,
          2,
        )}`,
      );
    }

    if (command === "push") {
      return multiline.stripIndent`
        ${commandComment}
        @${VM_fileNameLessExtension}.${value}
        D=M
        @SP
        M=M+1
        A=M-1
        M=D
      `;
    }

    if (command === "pop") {
      return multiline.stripIndent`
        ${commandComment}
        @SP
        AM=M-1
        D=M
        @${VM_fileNameLessExtension}.${value}
        M=D
      `;
    }
  }

  throw new Error(
    `Unhandled command: ${JSON.stringify(parsedCommand, null, 2)}`,
  );
}
